# Ingestion Workflow with the SIP-Creator Tool #

The SIP-Creator tool is a Graphical User Interface designed to enable people to transform input XML of any record-based format to specifically formatted XML records defined by Europeana Semantic Elements.

There is a great variety of challenges in transforming arbitrary formats into a desired format, although most mappings are straightforward verbatim copying.  Sometimes mapping requires some sophisticated manipulation of input data to make the correct output:

- combining content of multiple input fields to one output field
- splitting strings of characters of an element to create multiple elements
- embellishing content with prefixes and suffixes (often to build an URL)
- sophisticated extractions of data from element content (like year values)
- generating resolvable URLs using a hashing strategy

The most important feature of the SIP-Creator

## The Groovy Programming Language

Groovy is a rich and dynamic alternative to Java which can be very naturally integrated into a Java application. The SIP-Creator integrates Groovy in a way that allows you to make changes in the mapping code and see the results immediately in an output panel.  The application actually triggers a re-compile and execution of the Groovy mapping code whenever you stop editing it, and any errors are immediately reported.

### Code snippets

	output.record {
		// field mappings
	}

### Variables



### GStrings

### Regular expressions

### Pre-built converters


## Steps

The workflow for turning an input XML file into a correctly formatted or normalized output file consists of a number of steps.  The SIP-Creator tool shows these steps in different tabs, and allows you to skip back and forth among them.

### Select an input file, and perform analysis

Initially, the file menu allows you to select an input XML file using a file dialog, which starts its search at the root of your file system, but only the first time.  After navigating around and choosing an input file, the file menu option starts the file dialog up in a nearby folder.  A number of recent files are also available in the file menu, according to how recent they are.

Once a file is selected, the SIP-Creator indicates that the analysis has not yet been performed and a button at the bottom of the first tab called **"Analysis"**, and a button at the bottom is enabled which will initiate the analysis.

The number of XML elements (or tags) processed is shown at the bottom as the analysis progresses.  During analysis the SIP-Creator is gathering statistics about all of the elements it finds, focusing on their content.  The frequency of occurrence of the values for a given element for up to the top hundred most frequent values, which is useful in later phases of building a mapping.

Once the analysis is complete, a tree representing the nested XML structure of the input data file is presented on the leftmost panel of the **Analysis** tab. The SIP-Creator must now be informed as to which element represents a "record".

### Choose a record-delimiter element

Under the tree control is a button **Select Record Root** which is enabled when you have chosen an element of the analysis tree.

Before you can continue with the next steps, you must select the correct record root element. The record root delimits one record from the next in the input file, and it is often actually called **record** since the input is record-based, although of course not in general.

Once you have made your choice of record element, two things appear.  The panel on the right fills with the **input variables** that will be made available to Groovy mapping code for each record as it is parsed. These variables will reappear in subsequent stages. You can also see the number of records present in the input file based on your choice of record delimiter element, which can be used to verify your choice if the number of records is already known.

### Create initial mapping

A mapping at the field level consists of zero or more input variables and an output field, and 

- select one or more vars, or fill in constant value
- select an unmapped field
- obvious mappings
- mistake: delete mapping and re-create

### Refine mapping elements

It is in the mapping refinement process that you first encounter Groovy code and are given an opportunity to compose the resulting field contents using any of a number of strategies.

#### Verbatim copy statements

The code generated by default for every normal mapping is a small statement which adds **.each** to the end of the input variable to traverse each value, followed by a block of code surrounded by **braces {...}** which is executed for each entry.

	input.path.path.variable.each {
		ns_tag it
	}

The **it** variable represents the value that is extracted from each of the entries when this construction is used.

#### Embellishments

When a verbatim copy of the original values into the new fields is not enough, it is very easy to modify the **it** value to turn it into a so-called **GString** which can place the value in the context of a larger string.  Often this is used to build URLs from identifier values.

	input.path.path.variable.each {
		ns_tag "http://some/prefix/${it}"
	}

A GString is a string between double-quotes which uses the **dollar sign** to indicate that a variable from the environment is to be inserted.  The dollar sign can often precede simply a variable name (without braces), but adding braces allows you to use any arbitrary piece of Groovy code as the substitution.

#### Constant values

It is trivial to add the same constant value to each record of the normalized output.  The statement to do this is merely the output field followed by the constant value itself.

	ns_tag 'Constant value'

#### Selecting one of a number of input elements

When it is not appropriate to create output for every value in the input, but rather to use only one of the input values to create the output element, you can use the **array syntax** to pick members of the group.  Groovy array syntax is written as a number within square brackets, and it conveniently uses negative numbers to index from the end of the list rather than from the beginning.

	ns_tag input.path.variable[0] // first
	ns_tag input.path.variable[-1] // last
	
#### Splitting a content field

Sometimes a mapping requires that the content of a single element be split into pieces where each piece is to be an element in the output.  In cases like this, a **for-loop** is used to handle each of the parts of the split string.  For example, when the content consists of a number of values delimited by a semicolon, the snippet of Groovy mapping code might look like this:

	input.path.path.variable.each {
		for (part in it.toString().split(';')) {
			ns_tag part
		}
	}
	

#### Combining multiple fields into one

When an output field is to be built up from the content of multiple values from the input, the statement can be built as a field designation followed by a GString which refers

	ns_tag "length: $input.dimensions.length, width: $input.dimensions.width"

### Perform Normalization

The normalization tab shows three panels at the top: input, code, and output.  The input panel shows the variables from the parsed input record as well as their values.  There are buttons below this panel which allow you to move to the next record of the input file or to rewind back to the beginning.

The code panel shows the entire mapping code, consisting of all of the field-level mappings that you have built in the previous phases wrapped in code that makes it into a single **record** of output.  The output panel on the right shows the record that the code produces from the input values on the left.

These three panels allow you to observe a dry-run of the normalization one record at a time so that you can visually verify the the output record looks right.

When you are satisfied with the records that are being produced in the dry-run you can press the **Normalize** button to start the normalization of the entire input file to produce the output file.  While it is normalizing, the SIP-Creator shows its progress along the bottom.




