# Ingestion Workflow with the SIP-Creator Tool #

The SIP-Creator is a standalone Java application designed to enable people to transform any record-based XML input into the format required for ingestion into the Europeana platform. SIP stands for **Submission Information Package**, and in this context the information submitted will be the original XML file combined with a specification of how it will be mapped to the new format.

## Introduction ##

Experience has taught us that we will encounter a huge variety of challenges when we need to map XML from very different sources, although most mappings are very straightforward.  The SIP-Creator makes easy mappings very quick but its real power starts to appear when we encounter difficult corner cases.

By their nature it's not really possible to document all the types of corner cases we might encounter, but we clearly need to be able to handle a number of sophisticated manipulations:

- combining content of multiple input fields to one output field
- splitting strings of characters of an element to create multiple elements
- embellishing content with prefixes and suffixes (often to build an URL)
- sophisticated extractions of data from element content (like year values)
- generating resolvable URLs using a hashing strategy

To tackle these and other problems which we have not yet seen, a very flexible approach is needed. Typical XML transformation technologies like XSLT often fall short or become extremely verbose and unreadable when charged with solving a corner case. The SIP-Creator takes a quite different approach by carefully integrating a general-purpose programming language to do the mapping work: **Groovy**.

Groovy is a rich and expressive scripting language which is so related to Java that it is very natural to build it right into a Java application. The SIP-Creator has Groovy integrated in such a way that the user can edit the snippets of Groovy code and see the results of the changes they make immediately.  The Groovy code is "live", which makes learning the necessary elements of the language quite easy.

As user of the SIP-Creator, you need not have a full understanding of the Groovy language, since by no means all aspects of the language are used. The Groovy code that you edit appears only in very small snippets, and they are initially generated by the SIP-Creator automatically. This manual will guide you through most of the Groovy tricks that you will ever need.

To build a mapping you must go through four stages, indicated by different tabs in the interface.

1. First the source XML file is analyzed, statistics are gathered, and you are asked to select the XML element which separates one record from the next.

2. Then by making selections you build the initial rough mapping, and to make it easier many straightforward mapping choices are made automatically for you.

3. Next, you enter the refinement phase where each mapping can be viewed and edited. This is the only place where you edit Groovy code.

4. Finally the normalization can be done when the mapping is complete, and you can verify that the mapping is correct by stepping through records and seeing the results in a kind of dry-run.

The SIP-Creator has built-in validation of the resulting record, so you will be able to see a report of anything in your mapping that is producing invalid records.

## Step One : Analysis, Record Root Choice, Constants

The **File** menu makes it possible to select a source XML file using a pop-up file dialog box. When you start the application for the very first time, this file dialog is set to search from the root of your file system, but after you have chosen input files it gives options for opening other files in the vicinity.  Recent files are made available in the file menu as well.

Once a file is selected, the SIP-Creator indicates that the analysis has not yet been performed and a button at the bottom of the **Analysis** tab is enabled which will start the analysis. Beside that button you can see the number of XML elements processed as it proceeds.

During analysis the SIP-Creator is gathering statistics about all of the elements it finds, counting them and compiling a list of the different values they contain. When the analysis is complete, a tree representing the **Document Structure** appears. By selecting elements of the tree you can reveal the **Statistics** gathered about each one, including a list of the 100 most frequent values when possible.

Under the tree control is a button **Select Record Root** which is enabled when you have chosen an element of the analysis tree. Before you can continue with the next steps, you must select the correct record root element. The record root delimits one record from the next in the input file, and it is often actually called **"record:** since the input is record-based, although of course not in general.

Once you have made your choice of record root, the panel on the right fills with the **Variables** that will be made available to the Groovy mapping code for each record as it is parsed. A number at the bottom also shows the how many records are present in the input file based on your choice of record root, which can be used to verify your choice if the number of records is already known.

Finally, the fields designated as **Constants** are presented for you to edit on the lower right. These values will be identical for every record in the normalized output, and they serve to distinguish one collection from another when all the different collections are ingested by the Europeana system, as well as specify potentially missing elements such as language and country.

## Step Two : Create the Rough Field Mappings

The second tab in the SIP-Creator application is called **Mapping** and this is where you build the record mapping as a collection of field mappings.

In general, creating a field mapping involves selecting one or more **Variables** for input, selecting the output field from the **Unmapped Fields** list, and pressing the **Create Mapping** button. The result is a straightforward verbatim copying of input to output, which is fine in most cases, but there are other options.

Sometimes an output field is to be a constant value for every record in the entire output, in which case you can fill in the **Constant Value** field instead of selecting variables, and then creating the mapping.

For convenience, the SIP-Creator is also able to identify a number of **obvious** field mappings which can be automatically generated, such as the mappings that make use of the **Constants** that you entered on the **Analysis** tab.

Another case in which the mappings are obvious is when the element names already correspond with those of the output fields, for example when the input contains familiar Dublin Core fields like **"dc:creator"**. For this as well, the application presents to you a single-click option to create these mappings, without the need to make any selections at all.

If at any point you discover that a mistaken mapping has been created, there is a button on the bottom right for deleting one that you select in the **Field Mappings** list.

Each of these mappings involve a small snippet of Groovy code, and the code for all the mappings together is combined to build a mapping for the entire record. All of the Groovy code so far have been generated behind the scenes. The code snippets only appear in the next phase: refinement.

## Step Three : Refining the Field Mappings

It is in the refinement process that you first encounter Groovy code and are given an opportunity to review and edit the snippets that were generated in the previous step. We will look at some examples of the generated snippets.

### Generated Snippets

First the very common ***verbatim copy snippet***:

	input.tag.subtag.variable.each {
		prefix.name it
	}

As you have seen in the **Variables** list on earlier tabs, each variable starts with **"input."** and is followed by a dotted path. Here the variable name is followed by **".each"** and a block of code between curly braces, indicating that the code block inside will be executed once for each occurrence of the variable.

Each time the code block is executed, the value of the occurrence is exposed through the **"it"** variable. The **prefix** here will be either "dc", "dcterms", or "europeana", and the name is the element within that prefix's namespace. By placing "it" after the "prefix.name", this output is produced:

	<prefix:name>[value of "it"]</prefix:name>

Even simpler is the ***literal value snippet***:

	prefix.name 'Culture'

Similar to the previous example, this produces the following XML:

	<prefix:name>Culture</prefix:name>

Similarly, we have the ***constant value snippet***:

	europeana.country europeana_country

The special constants that you filled in during step one are used here in almost exactly the same way as the literal example, except the variable name **europeana_country** is taken from the first tab and made available to the Groovy code, so the above snippet might produce:

	<europeana:country>NETHERLANDS</europeana:country>

### Built-in Converters

Certain types of field conversions are common enough that the SIP-Creator has included some specifically pre-written Groovy functions to handle them. This set of functions is currently small, but it will likely expand in the future.

One such function is for ***extracting a year***, which works like this:

	def it = 'Created in the year 1983'
	def year = extractYear(it)
	assert year == '1983'
	it = '1890-02-03 to 1892-03-21'
	year = extractYear(it)
	assert year == '1890, 1892'

This function is automatically inserted into the generated code snippet whenever you map to the fields that typically use it, like **"europeana:year"**.

	input.temporal.created.each {
   		europeana.year extractYear(it)
	}

Another essential function is for ***creating a europeana URI*** using a hash function:
	
	def record_id = "0001"
	europeana.uri createEuropeanaURI(record_id)

Which produces this URL:

	http://www.europeana.eu/resolve/record/0101/7A6779700F09E1EAFE9AD40E390F3A15B94DFA4B

Note that it has prefixed the hashed value with a URL that includes the path to the Europeana resolver, followed by **collectionId** which was one of the fields you had to fill in during step one.

### Simple Customizations

Often an input value needs to be put in ***context***:

When a verbatim copy of the original values into the new fields is not enough, it is very easy to replace **it** with a Groovy string which you can use to build a bigger string with the **it** value substituted inside.  Often this is used to build URLs from identifier values, such as in this example:

	input.body.description.thumbnail.each {
		europeana.isShownBy "http://somesite.eu/images/${ it }.jpg"
	}

A GString is a string between double-quotes which uses the **dollar sign** to indicate that a variable from the environment is to be inserted. The braces surrounding **it** can contain arbitrary Groovy code as you will see below.

Sometimes you may need to make a ***selection***:

When it is not desirable to create an element in the output for each element in the input, you can make a choice from the input using array notation with square brackets instead of using **.each** with a code block:

	europeana.isShownAt input.identity.thumbnail[0] // fetch the first one
	europeana.isShownAt input.identity.thumbnail[-1] // fetch the last one

Likewise, these selection values can be built into a GString:

	europeana.isShownAt "http://culturesource.eu/images/${ input.identity.thumbnail[0] }"	

Occasionally you have to build a ***combination***:

A GString can also just as easily be used to combine the values of multiple variables in the input to produce one element of the output. In this example, the input contains width and height dimensions, while we want the output to summarize them into one field called "format"

	dc.format "length: ${input.dimensions.length}, width: ${input.dimensions.width}"

This combination example is something that you would have to create by editing the code because nothing like this will be automatically generated.

### Advanced Refinement

This is the point at which it might start to seem complicated, because for advanced manipulation of the input you have to delve deeper into the Groovy language, and that may not be for everyone.

The first advanced challenge is to ***split an input value***:

Sometimes a mapping requires that the content of a single element be split into pieces where each piece is to be an element in the output.  In cases like this, a **for-loop** is used to handle each of the parts of the split string.

Suppose an input element has this form:

	<authors>Einstein;Rosen;Podolsky</authors>

But what we would like to have in the output is:

	<dc:creator>Einstein</dc:creator>
	<dc:creator>Rosen</dc:creator>
	<dc:creator>Podolsky</dc:creator>

The following code, with a for-loop inside the code block, would do it:

	input.source.authors.each {
		for (part in it.split(';')) {
			dc.creator part
		}
	}

A much stranger corner case would be to ***split and interpret a value***:

Suppose we have this as input:

	<movie>Star Wars:T/George Lucas:D/20th Century Fox:P</movie>

What we need to do is split it up and produce different elements, which is a challenge indeed. Groovy can help us, although this may be difficult for non-programmers to follow.

	input.movies.movie.each {
		for (part in it.split('/')) {
			def chunk = part.split(':')
			def name = chunk[0]
			def role = chunk[1]
			switch (role) {
				case 'P':
					dc.publisher name
				case 'T':
					dc.title name
					break;
				case 'D':
					dc.creator name
					break;
			}
		}
	}

The above code would produce this:

	<dc:title>Star Wars</dc:title>
	<dc:creator>George Lucas</dc:creator>
	<dc:publisher>20th Century Fox</dc:publisher>

Needless to say the diversity of tricks that you can use is endless, but the deeper you get the more basic Groovy knowledge and experience you need to have.

## Step Four : Normalization and Validation

The **Normalization** tab shows three panels at the top: input, code, and output.  The input panel shows the variables from the **Parsed Record** as well as their values.  There are buttons below this panel which allow you to move to the next record of the input file or to rewind back to the beginning.
The middle panel shows the **Groovy Code** which does the mapping work, converting the parsed input record into the **Output Record**.  It consisting of all of the field-level mappings that you have built in the previous phases wrapped in code that makes it into a single record of output.  The panel on the right shows the record that the code produces from the input values on the left.

Validation errors will be apparent in the **Output Record** panel on the right if something is wrong with the record according to the validation criteria.

These three panels allow you to observe a dry-run of the normalization one record at a time so that you can visually verify the the output record looks right.

When you are satisfied with the records that are being produced in the dry-run you can press the **Normalize** button to start the normalization of the entire input file to produce the output file.  While it is normalizing, the SIP-Creator shows its progress along the bottom.

